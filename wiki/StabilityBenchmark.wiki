#summary Description of the stability benchmark test.

= Introduction =

Stability and accuracy of several important decomposition algorithms and linear solvers is tested in each library.  Three types of tests are performed for all algorithms; accuracy, overflow, and underflow.  A fourth type of test is also done for linear solvers that test their ability to handle nearly singular systems.  Accuracy tests the ability to accurately decompose a well formed matrix.  Overflow and underflow test their ability to handle very large and small numbers respectively.  

Each test is performed several times using randomly generated matrices.  The tests are also performed across a range of matrix sizes.  Randomly generated matrices are used to provide a good range of tests.  The disadvantage of this approach is that particularly stressing cases might be missed.    In general the specialized stressing cases are specific for a particular algorithm/implementation and are not included since this is a general purpose benchmark.  It is possible for an algorithm to perform very well in these tests, but perform poorly for a particular application.

There are two reason for testing different sizes of matrices.  Some libraries switch between different algorithms depending on the size and some errors become more noticeable for larger matrices.  Three sets of matrix sizes are tested; small, medium, and large:
||        || min  || max || 
|| Small  ||  2   || 20  || 
|| Medium || 100  || 200 ||
|| Large  || 500  || 600 ||

= Metrics =

Depending on the test different metrics are used.  Accuracy is measured as the frobenius norm of the difference between the expected and found results.  The specifics for how this is computed for each solver/decomposition is provided below.  Overflow/underflow tests work by scaling up or down a matrix until a stopping condition is encountered.  For overflow tests larger numbers are better with infinity being the best.  For underflow small numbers are better.

== Stopping Condition ==

There are special different reasons for an individual test to stop, which are shown below:

|| Finished || The test finished with no error. ||
|| Large Error || The difference from the expected result was too large. ||
|| Uncountable || A matrix was returned with at least one element that was not a countable number (infinity or NaN) ||
|| Unexpected Exception || An unexpected exception was thrown.  For example a null pointer exception would be unexpected ||
|| Graceful || The algorithm detected that it has failed. For example, a specified exception could be thrown and value of false could be returned.  ||

Each set of trials is given a finite (but generous) amount of time to run.  Failure to finish running in that amount of time is considered a complete failure.  This can be because the operation had frozen (which is a common problem in multi-threaded algorithms) or was simply too slow.  Due to the halting problem it is impossible to tell the difference between the two.  As a general rule for small and medium matrix tests if it times out then it is a bug in the algorithm.  For large matrices it might just be slow but it could also be frozen.

= Benchmarks =

== Solve: Linear and Least Squares  ==

Both linear and least squares problems are described by the following equation:
Ax = y
where A is m by n, x is n by 1 and y is m by 1.  For linear equations m = n and for least squares m > n.  The matrix x is unknown and solved for.

Accuracy is computed with:

error = |y-Ax|<sub>2</sub>

All tests start with a randomly generated matrix whose singular values are all one.  Such matrices can be easily solved for.  For the accuracy test this matrix is used as is, for overflow/underflow tests it is scaled up/down.  In the nearly singular test one singular value is randomly selected and scaled down.  The smaller the singular value is before the algorithm breaks the better.

== Singular Value Decomposition ==

The accuracy of SVD is computed with:

error = |A-USV<sup>T</sup>|

where U,S, and V is the SVD of A.  It is tested against randomly generated matrices that have a singular value of one.

To ensure reasonable scaling the test matrices have all have singular values of one initially.
*NOTE: Change this to nearly one to avoid an unrealistic pathological case*

== Eigenvalue Decomposition ==

The accuracy of an Eigenvalue decomposition is computed with:

error = |AV - LV|

where V is a matrix composed of the eigenvectors and L is a matrix composed of the eigenvalues.  If the eigenvalues are all positive then it is a diagonal matrix.

Currently only symmetric matrices are tested.  This problem is important in many engineering and scientific applications and has a solution contained in the real domain.  The general eigenvalue problem involves imaginary numbers, which goes beyond the scale of this benchmark.

To ensure reasonable scaling the test matrices have all have singular values of one initially.
*NOTE: Change this to nearly one to avoid an unrealistic pathological case*