#summary Summary of performance benchmarks.

= Libraries Summary =

Below is a summary of each of the libraries that were tested.  The columns indicates features of each libraries implementations that are important for understanding the results.

|| Name || Version         || Multi-Threaded || Physical <br> Transpose || Cached <br> Results || In-Place ||
|| EJML ||  0.7            ||       || True  ||      ||      ||
|| Colt ||  1.2            || True  ||       ||      || True ||
|| Commons Math || 2.0     ||       || True  ||      ||      ||
|| Jama || 1.0.2           ||       || True  ||      ||      ||
|| JScience || 4.3         || True  ||       ||      ||      ||
|| MTJ || 0.9.12           ||       || True  ||      || True ||
|| OjAlgo || 28.26         || True  ||       || True ||      ||
|| Parallel Colt || 0.9.1  || True  ||       ||      || True ||
|| UJMP || 0.2.3           ||       || True  ||      ||      ||

== Benchmark/Library Design Issues ==

One problem that is encountered when benchmarking linear algebra libraries, is that they often do not implement the exact same operation.  Often times some massaging is required before they will produce the desired results.  Here are some issues that were encounted 1) how transpose is performed, 2) caching of results, 3) only computing partial solutions, 4) only providing in-place operations.

=== Transpose ===
Libraries whose algorithms operate with accessors instead of the raw data can simply mark a matrix as being transposed.  When a get(x,y) function is called it internally swaps the x and y if it has been flagged. A library that physically transposes a matrix moves the memory around and no check needs to be done to see if it has been transposed.  For the transpose benchmark, libraries that do not perform a physical transpose are omitted.

=== Caching ===
If a matrix has not changed, then there is no need to recompute expensive operations on that matrix.  This can make things simpler for a developer, but increases the memory requirements of the library and its complexity.  It can also wreck havoc on benchmarks, since what is supposed to be measured is its performance at computing an operation.  

The work around for this issue is to tell the library to forget its past results. For small matrices this might effect the results, for larger ones the performance will be insignificantly degraded.

=== Partial Results ===
When computing a decomposition of a matrix, not all the results are needed all the time.  Many of the libraries will postpone some computations until the full solution has been requested.  As a way around this issue the full decomposition is requested from all libraries.  This will not bias the results, but libraries with this feature might run faster in real-world applications.

=== In-Place ====
An in-place operation is an operation which modifies one of the original matrices instead of storing the results in another matrix.  Most libraries provide methods for the later, which is what this benchmark evaluated.  If a library only provides an in-place method, then a copy of the original matrix is created.  This will degrade performance for small matrices.  If a library is flagged as in-place above, then for at least one operation only an in-place variant was provided.

Effected operators are 'scale' and 'add' in Colt, Parallel Colt and MTJ libraries.

= Operations Tested =

Three primary types of operations are tested; basic, solving, and decompositions.  If a library did not support one of the operations it was simply omitted from that test.

== Basic Operations ==

The following are several common operations used in linear algebra.  There are many different permutations on these that some libraries support.  For sake of brevity, only a few have been tested.

|| Operation || Description ||
|| {{{C = Î± * B}}} || Scaling ||
|| {{{C = A + B}}} || Addition ||
|| {{{C = A * B}}} || Matrix multiplication ||
|| C = A<sup>T</sup> {{{*}}} B || Transpose then multiplication. ||
|| det(A) || Determinant ||
|| C = A<sup>T</sup> || Physical transpose ||
|| C = inv(A) || Invert ||

== Linear Solving ==

Most libraries provided ways to solve for linear systems.  Typically there are different algorithms used when a square system is being solved for versus an overdetermined system.  Thus there are two benchmarks.

|| Operation || Description ||
|| {{{A*x = b}}} where m=n|| Solving for x when A is a square non-singular matrix.||
|| {{{A*x = b}}} where m>n|| Solving for x when it is an overdetermined system.||

== Decompositions ==

After each library performs a decomposition the decomposed matrices are then requested.  *NOTE: this is only done for SVD and eigen right now.*

|| Operation || Description ||
|| LU || Square non-singular matrices. ||
|| Cholesky || Square positive definite matrices. ||
|| QR || Rectangular matrices where m > n ||
|| SVD || Square matrix. ||
|| Eigen || Symmetric square matrix. ||