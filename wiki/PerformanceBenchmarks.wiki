#summary Summary of performance benchmarks.

= Introduction =

The following is a summary what was evaluated and why.

= Java Matrix Benchmark Settings =

This is how the benchmark was configured.  See the code for an explanation of these settings.

|| Setting || Value ||
|| numBlockTrials || 5 ||
|| numBlocks || 5 ||
|| TRIAL_TIME || 3000 ||
|| memorySlaveBase || 10 ||
|| memorySlaveScale || 8 ||
|| randizeOrder || true ||

= Libraries Summary =

Here are the libraries that were tested.

|| Name || Version         || Multi-Threaded || Physical Transpose || Caches Results ||
|| EJML ||  0.7            ||       || true  ||      ||
|| Colt ||  1.2            || true  ||       ||      ||
|| Commons Math || 2.0     ||       || true  ||      ||
|| Jama || 1.0.2           ||       || true  ||      ||
|| JScience || 4.3         || true  ||       ||      ||
|| MTJ || 0.9.12           ||       || true  || true ||
|| OjAlgo || 28.26         || true  ||       ||      ||
|| Parallel Colt || 0.9.1  || true  ||       ||      ||
|| UJMP || 0.2.3           ||       || true  ||      ||

== Benchmark/Library Design Issues ==

One problem that is encountered when benchmarking linear algebra libraries is that they often do not implement the exact same operation.  Here are three issues common issues transpose, caching, and partial solutions.

Libraries that work with accessors instead of the raw data can simply mark a matrix as being transposed.  When a get(x,y) function is called it internally swaps the x and y if it has been flagged. A library that physically transposes a matrix moves the memory around and no check needs to be done to see if it has been transposed.  For the transpose benchmark libraries that do not perform a physical transpose are omitted.

If a matrix has not changed then there is no need to recompute expensive operations on that matrix.  This can make things simpler for a developer, but increases the memory requirements of the library and its complexity.  It can also wreck havoc on benchmarks, since what is supposed to be measured is its performance at computing the operation, not caching its results.  

The work around for this issue is to tell the library to forget its past results.  Which is accomplished by either creating a new copy of the matrix or telling it to flush its cache.  As a result test results for these libraries will be biased against it for small matrices.

When computing a decomposition of a matrix not all the results are needed all the time or the results need to be extracted from a partial solution.  Many of the libraries will postpone some computations until the full solution has been requested.  As a way around this issue the full decomposition is requested from all libraries.  This will not bias the results.

= Operations Tested =

Three primary types of operations are tested; basic, solving, and decompositions.  If a library did not support one of the operations it was simply omitted from that test.

== Basic Operations ==

The following are several common operations used in linear algebra.  There are many different permutations on these that some libraries support.  Testing them all is not of practical value.

Matrix transpose is primarily handled in two ways by the libraries.  In some it is a physical transpose where a new matrix is created and the transpose written to it.  In others a matrix is just flagged as being transposed.  The transpose benchmark only tested a physical transpose.  However, to test the merits of flagging a library as being transposed, a transpose then multiplication operation was also tested.

|| Operation || Description ||
|| {{{C = Î± * B}}} || Scaling ||
|| {{{C = A + B}}} || Addition ||
|| {{{C = A * B}}} || Matrix multiplication ||
|| C = A<sup>T</sup> {{{*}}} B || Transpose then multiplication. ||
|| det(A) || Determinant ||
|| C = A<sup>T</sup> || Physical transpose ||
|| C = inv(A) || Invert ||

== Linear Solving ==

Most libraries provided ways to solve for linear systems.  Typically there are different algorithms used when a square system is being solved for versus an overdetermined system.  Thus there are two benchmarks.

|| Operation || Description ||
|| {{{A*x = b}}} where m=n|| Solving for x when A is a square non-singular matrix.||
|| {{{A*x = b}}} where m>n|| Solving for x when it is an overdetermined system.||

== Decompositions ==

Internally how each library performed decompositions varied significantly.  For example,
some out extract all the decomposed matrices at once, while others would only extract
them upon request.  To overcome this problem all of the decompositions tests would first
request that they decompose the matrix, then extract each of the decomposed matrices.

One could argue that extracting the decomposed matrices is often an unnecessary.  While
true, one would also need to understand the internals of how the algorithm worked to avoid doing so.  

|| Operation || Description ||
|| LU || Square non-singular matrices. ||
|| Cholesky || Square positive definite matrices. ||
|| QR || Rectangular matrices where m > n ||
|| SVD || Square matrix. ||
|| Eigen || Symmetric square matrix. ||